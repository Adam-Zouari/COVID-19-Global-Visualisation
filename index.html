<!DOCTYPE html>

<head>
    <title>COVID-19 Visualizer</title>
    <!-- Meta -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- CSS / Favicon -->
    <link href="styles.css" rel="stylesheet" />
    
    <!-- JavaScript -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script src="dataService.js" defer></script>
    <script src="globe.js" defer></script>
</head>

<body>
    <div id="particles"></div>
    <div id="globe" class="centered-globe"></div>

    <div id="header">
        <div id="search">
            <img src="assets/icons/search.svg" onclick="openSearch()">
        </div>
        
        <!-- Replace SVG use elements with direct image references -->
        <div class="dataset-buttons">
            <button id="epidemBtn" class="dataset-btn active" onclick="changeDataset('epidem')" title="Epidemiology">
                <img src="assets/icons/virus.svg" class="dataset-icon" alt="Epidemiology">
            </button>
            <button id="hospBtn" class="dataset-btn" onclick="changeDataset('hospitalizations')" title="Hospitalizations">
                <img src="assets/icons/hospital.svg" class="dataset-icon" alt="Hospitalizations">
            </button>
            <button id="vaccBtn" class="dataset-btn" onclick="changeDataset('vaccinations')" title="Vaccinations">
                <img src="assets/icons/syringe.svg" class="dataset-icon" alt="Vaccinations">
            </button>
        </div>
        
        <h1>COVID-19</h1>
    </div>
    
    <!-- Search Modal Overlay -->
    <div id="searchModal" class="search-modal">
        <div class="search-container">
            <div class="search-header">
                <h3>Search Countries</h3>
                <button class="close-search" onclick="closeSearch()">×</button>
            </div>
            <input type="text" id="countrySearchInput" placeholder="Type country name..." autocomplete="off">
            <div id="countryList" class="country-list"></div>
        </div>
    </div>
    
    <div id="loader"></div>
    
    <!-- Country Info Panel -->
    <div id="countryInfo">
        <h3 id="countryName">Select a country</h3>
        <div id="countryStats"></div>
        <!-- Add the See More button -->
        <button id="seeMoreBtn" onclick="showVisualizations()">See More Visualizations</button>
    </div>
    
    <!-- Controls Panel -->
    <div class="control-panel">
        <!-- Removed the dataset buttons -->
        <div class="dataset-indicator">
            <span id="currentDataset">Epidemiology</span>
        </div>
        
        <div class="data-selector-container">
            <label for="dataSelector">Data Type: </label>
            <select id="dataSelector"></select>
        </div>
        
        <div class="date-controls">
            <button id="prevDateBtn">&lt;</button>
            <span id="currentDate">Loading...</span>
            <button id="nextDateBtn">&gt;</button>
        </div>
        
        <input type="range" id="dateSlider" min="0" max="100" value="0">
        
        <button id="resetBtn" class="control-btn">Reset View</button>
    </div>
    
    <div id="dataStatus">Loading data...</div>
    
    <!-- Error display for data loading issues -->
    <div id="errorDisplay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; color: white; padding: 20px; flex-direction: column; align-items: center; justify-content: center;">
        <h2>Data Loading Error</h2>
        <div id="errorMessage"></div>
        <button id="errorClose" style="margin-top: 20px; padding: 8px 16px;">Close</button>
    </div>
    
    <!-- New Visualization Panel -->
    <div id="visualizationPanel">
        <div class="viz-header">
            <div class="viz-title">
                <img id="viz-flag" src="" alt="Country Flag">
                <h2 id="viz-country-name">Country Data</h2>
            </div>
            <div class="viz-controls">
                <select id="vizTypeSelector" class="viz-selector" onchange="changeVisualization()">
                    <option value="bar">Bar Chart</option>
                    <option value="line">Line Chart</option>
                    <option value="pie">Pie Chart</option>
                    <option value="radar">Radar Chart</option>
                    <option value="heatmap">Heat Map</option>
                </select>
                <!-- Removed the vizDataSelector dropdown -->
            </div>
        </div>
        <div class="viz-content">
            <div id="chartContainer" class="chart-container"></div>
        </div>
    </div>
    
    <!-- Minimized Globe Container (appears when globe is minimized) -->
    <div id="minimizedGlobe" class="globe-minimized" style="display:none" onclick="restoreGlobe()"></div>

    <script>
        // Hide loader when the globe is initialized
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                const loader = document.getElementById('loader');
                if (loader) {
                    loader.style.display = 'none';
                }
            }, 2000); // Give some time for data to load
            
            // Center the globe visualization properly
            document.addEventListener('GlobeVisualizationInitialized', function() {
                const globeInstance = window.globeInstance;
                if (globeInstance) {
                    // Adjust the globe position to be centered and higher
                    globeInstance.globeGroup.attr('transform', 
                        `translate(${window.innerWidth / 2}, ${window.innerHeight / 2 - 50})`); // Move up by 50px
                    
                    // Update the backdrop position
                    d3.select('.globe-backdrop')
                        .attr('cx', window.innerWidth / 2)
                        .attr('cy', window.innerHeight / 2 - 50); // Move up by 50px
                        
                    // Force a redraw of the globe
                    globeInstance.globeGroup.selectAll('path')
                        .attr('d', globeInstance.path);
                    
                    // Initialize with the default dataset background without animation
                    document.body.style.background = 'radial-gradient(#4a0000, #000)';
                    
                    // Initialize reset button color to match default dataset (epidem)
                    globeInstance.updateResetButtonColor('epidem');
                }
            });
            
            // Initialize particles.js with configuration - fewer particles and no stars behind globe
            particlesJS('particles', {
                "particles": {
                    "number": {
                        "value": 70,
                        "density": {
                            "enable": true,
                            "value_area": 800
                        }
                    },
                    "color": {
                        "value": "#ffffff"
                    },
                    "shape": {
                        "type": "circle",
                        "stroke": {
                            "width": 0,
                            "color": "#000000"
                        }
                    },
                    "opacity": {
                        "value": 0.3,
                        "random": true,
                        "anim": {
                            "enable": true,
                            "speed": 0.5,
                            "opacity_min": 0.1,
                            "sync": false
                        }
                    },
                    "size": {
                        "value": 2,
                        "random": true,
                        "anim": {
                            "enable": true,
                            "speed": 2,
                            "size_min": 0.1,
                            "sync": false
                        }
                    },
                    "line_linked": {
                        "enable": false
                    },
                    "move": {
                        "enable": true,
                        "speed": 1.2,
                        "direction": "none",
                        "random": true,
                        "straight": false,
                        "out_mode": "out",
                        "bounce": false,
                        "attract": {
                            "enable": true,
                            "rotateX": 600,
                            "rotateY": 1200
                        }
                    }
                },
                "interactivity": {
                    "detect_on": "canvas",
                    "events": {
                        "onhover": {
                            "enable": true,
                            "mode": "bubble"
                        },
                        "onclick": {
                            "enable": false
                        },
                        "resize": true
                    },
                    "modes": {
                        "bubble": {
                            "distance": 150,
                            "size": 3,
                            "duration": 2,
                            "opacity": 0.5,
                            "speed": 3
                        }
                    }
                },
                "retina_detect": true
            });
        });
        
        // Replace toggleDataset function with direct dataset change function
        function changeDataset(datasetKey) {
            if (!window.globeInstance) return;
            
            // Update the dataset name display
            const datasetDisplayNames = {
                'epidem': 'Epidemiology',
                'hospitalizations': 'Hospitalizations',
                'vaccinations': 'Vaccinations'
            };
            
            // Update the current dataset display text
            const currentDatasetEl = document.getElementById('currentDataset');
            if (currentDatasetEl) {
                currentDatasetEl.textContent = datasetDisplayNames[datasetKey] || datasetKey;
            }
            
            // Change dataset in the globe visualization
            window.globeInstance.changeDataset(datasetKey);
            
            // Update button active states
            document.querySelectorAll('.dataset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Activate the selected button
            const buttonMap = {
                'epidem': 'epidemBtn',
                'hospitalizations': 'hospBtn',
                'vaccinations': 'vaccBtn'
            };
            
            const activeBtn = document.getElementById(buttonMap[datasetKey]);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            // If a visualization is visible, update it with the new dataset
            const vizPanel = document.getElementById('visualizationPanel');
            if (vizPanel && vizPanel.style.display === 'flex') {
                // Wait a moment for the dataset to change, then update visualization
                setTimeout(() => {
                    changeVisualization();
                }, 100);
            }
        }
        
        // Search functionality
        function openSearch() {
            document.getElementById('searchModal').classList.add('active');
            document.getElementById('countrySearchInput').value = ''; // Clear previous search
            document.getElementById('countrySearchInput').focus();
            
            // Always populate the country list when opening search
            populateCountryList();
        }
        
        function closeSearch() {
            document.getElementById('searchModal').classList.remove('active');
        }
        
        function populateCountryList() {
            if (!window.globeInstance) return;
            
            const countryList = document.getElementById('countryList');
            countryList.innerHTML = '';
            
            // Get all countries from the dataService
            const countries = window.globeInstance.dataService.getAllCountries();
            
            if (countries.length === 0) {
                // If no countries are found, show a message
                countryList.innerHTML = '<div class="no-countries">Loading countries... Please wait.</div>';
                
                // Try again in a moment - data might still be loading
                setTimeout(() => {
                    const retryCountries = window.globeInstance.dataService.getAllCountries();
                    if (retryCountries.length > 0) {
                        populateCountryList();
                    }
                }, 1000);
                return;
            }
            
            // Sort countries alphabetically by name
            countries.sort((a, b) => a.countryName.localeCompare(b.countryName));
            
            // Create elements for each country
            countries.forEach(country => {
                const countryItem = document.createElement('div');
                countryItem.className = 'country-item';
                countryItem.innerHTML = `
                    <img class="country-flag" src="https://flagcdn.com/${country.countryCode.toLowerCase()}.svg" 
                         onerror="this.src='https://via.placeholder.com/24x16/ddd/aaa?text=?'">
                    <span>${country.countryName}</span>
                `;
                
                countryItem.addEventListener('click', () => {
                    window.globeInstance.goToCountry(country.countryCode);
                    closeSearch();
                });
                
                countryList.appendChild(countryItem);
            });
            
            // Set up live filtering
            document.getElementById('countrySearchInput').addEventListener('input', filterCountries);
        }
        
        function filterCountries() {
            const input = document.getElementById('countrySearchInput');
            const filter = input.value.toUpperCase();
            const countryList = document.getElementById('countryList');
            const countryItems = countryList.getElementsByClassName('country-item');
            
            for (let i = 0; i < countryItems.length; i++) {
                const span = countryItems[i].getElementsByTagName('span')[0];
                const txtValue = span.textContent || span.innerText;
                
                if (txtValue.toUpperCase().indexOf(filter) > -1) {
                    countryItems[i].style.display = '';
                } else {
                    countryItems[i].style.display = 'none';
                }
            }
        }
        
        // Function to show visualizations panel and minimize globe
        function showVisualizations() {
            if (!window.globeInstance || !window.globeInstance.selectedCountry) return;
            
            const globe = document.getElementById('globe');
            const vizPanel = document.getElementById('visualizationPanel');
            const minimizedGlobe = document.getElementById('minimizedGlobe');
            
            // Get the current country data
            const countryEl = document.getElementById(`country-${window.globeInstance.selectedCountry}`);
            const countryCode = countryEl ? countryEl.getAttribute('data-country-code') : null;
            const countryData = window.globeInstance.dataService.getCountryData(countryCode);
            
            if (!countryData) return;
            
            // Set flag and country name in visualization panel
            document.getElementById('viz-flag').src = `https://flagcdn.com/${countryCode.toLowerCase()}.svg`;
            document.getElementById('viz-country-name').textContent = countryData.countryName;
            
            // Start fade-out animation for main globe
            globe.classList.add('globe-animating');
            
            // After animation completes, show the visualization panel
            setTimeout(() => {
                // Hide main globe
                globe.style.display = 'none';
                
                // Clear the mini globe container first
                minimizedGlobe.innerHTML = '';
                
                // Create mini globe using the globe instance's method 
                window.globeInstance.createMinimizedGlobe();
                
                // Show minimized globe with fade-in animation
                minimizedGlobe.style.display = 'block';
                minimizedGlobe.classList.add('showing');
                
                // Show visualization panel with animation
                vizPanel.style.display = 'flex';
                vizPanel.classList.add('panel-appearing');
                
                // Generate initial visualization
                changeVisualization();
            }, 400); // Match the fade-out animation duration
        }
        
        // Function to restore globe to original size
        function restoreGlobe() {
            const globe = document.getElementById('globe');
            const vizPanel = document.getElementById('visualizationPanel');
            const minimizedGlobe = document.getElementById('minimizedGlobe');
            
            // Start fade out animation for mini globe
            minimizedGlobe.classList.remove('showing');
            minimizedGlobe.classList.add('hiding');
            
            // Hide visualization panel with fade out
            vizPanel.style.opacity = '0';
            vizPanel.classList.remove('panel-appearing');
            
            // Wait for mini globe to fade out before showing main globe
            setTimeout(() => {
                // Hide minimized globe
                minimizedGlobe.style.display = 'none';
                minimizedGlobe.classList.remove('hiding');
                
                // Prepare main globe for fade in
                globe.style.display = 'block';
                globe.style.opacity = '0';
                globe.classList.remove('globe-animating');
                globe.classList.add('globe-restoring');
                
                // Re-render the globe to ensure proper display
                if (window.globeInstance) {
                    window.globeInstance.renderCountriesByDepth();
                }
                
                // Hide visualization panel after its fade out completes
                vizPanel.style.display = 'none';
                
                // Trigger browser reflow to ensure animation works
                void globe.offsetWidth;
                
                // Fade in the main globe
                globe.style.opacity = '1';
            }, 400); // Match the fade-out animation duration
        }
        
        // Chart Factory - A modular approach to creating visualizations
        const ChartFactory = {
            // Core visualization methods
            createChart(container, countryCode, vizType) {
                // Clear the container
                container.innerHTML = '';
                
                // Add loading state
                this.showLoading(container);
                
                // Get the data
                const data = this.prepareDataForCountry(countryCode);
                
                if (!data || !data.dates || data.dates.length === 0) {
                    this.showError(container, "No data available for this country");
                    return;
                }
                
                // Clear loading indicator
                container.innerHTML = '';
                
                // Create the appropriate chart
                switch (vizType) {
                    case 'bar': 
                        this.barChart(container, data);
                        break;
                    case 'line': 
                        this.lineChart(container, data);
                        break;
                    case 'pie': 
                        this.pieChart(container, data);
                        break;
                    case 'radar': 
                        this.radarChart(container, data);
                        break;
                    case 'heatmap': 
                        this.heatmapChart(container, data);
                        break;
                    default:
                        this.showError(container, `Chart type "${vizType}" not supported`);
                }
            },
            
            // Data preparation
            prepareDataForCountry(countryCode) {
                const dataService = window.globeInstance.dataService;
                
                // Validate we have a data service
                if (!dataService || !dataService.availableDates) {
                    console.error("Data service or available dates not found");
                    return null;
                }
                
                // Get all available dates
                const dates = dataService.availableDates;
                
                if (dates.length === 0) {
                    console.warn("No dates available in data service");
                    return null;
                }
                
                // Get current dataset and its columns
                const currentDataset = dataService.currentDataset;
                const columns = dataService.availableColumns[currentDataset] || [];
                
                if (columns.length === 0) {
                    console.warn("No columns available for dataset", currentDataset);
                    return null;
                }
                
                // Initialize the result structure
                const result = {
                    countryCode,
                    countryName: dataService.getCountryName(countryCode),
                    dates: [],
                    displayDates: [], // formatted dates
                    columns,
                    series: {}
                };
                
                // Initialize series data
                columns.forEach(col => {
                    result.series[col] = [];
                });
                
                // Collect data for each date
                dates.forEach(date => {
                    const dateData = dataService.getDataForDate(date);
                    
                    if (dateData && dateData[countryCode]) {
                        const countryDateData = dateData[countryCode];
                        const hasData = columns.some(col => 
                            col in countryDateData && 
                            countryDateData[col] !== null && 
                            countryDateData[col] !== undefined
                        );
                        
                        if (hasData) {
                            result.dates.push(date);
                            result.displayDates.push(dataService.formatDate(date));
                            
                            // For each column, add the value (or null)
                            columns.forEach(col => {
                                const value = countryDateData[col];
                                result.series[col].push(value);
                            });
                        }
                    }
                });
                
                console.log(`Prepared data for ${countryCode}: ${result.dates.length} dates across ${columns.length} columns`);
                return result;
            },
            
            // Helper UI methods
            showLoading(container) {
                const loader = document.createElement('div');
                loader.className = 'chart-loader';
                loader.innerHTML = `
                    <div class="spinner"></div>
                    <div class="loading-text">Loading data...</div>
                `;
                container.appendChild(loader);
            },
            
            showError(container, message) {
                container.innerHTML = `
                    <div class="chart-error">
                        <div class="error-icon">⚠️</div>
                        <div class="error-message">${message}</div>
                        <div class="error-suggestion">Try selecting a different country or visualization type.</div>
                    </div>
                `;
            },
            
            // Chart creation methods
            barChart(container, data) {
                // Create SVG element
                const margin = { top: 50, right: 150, bottom: 80, left: 80 };
                const width = container.clientWidth - margin.left - margin.right;
                const height = container.clientHeight - margin.top - margin.bottom;
                
                // Create SVG
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', container.clientWidth)
                    .attr('height', container.clientHeight)
                    .append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                    
                // Add title
                svg.append('text')
                    .attr('class', 'chart-title')
                    .attr('x', width / 2)
                    .attr('y', -25)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '16px')
                    .style('fill', 'white')
                    .text(`${data.countryName} - Data Comparison`);
                
                // Limit to most recent dates for readability
                const maxDates = Math.min(15, data.displayDates.length);
                const recentDates = data.displayDates.slice(-maxDates);
                
                // X scale
                const x = d3.scaleBand()
                    .domain(recentDates)
                    .range([0, width])
                    .padding(0.2);
                    
                // Add X axis
                svg.append('g')
                    .attr('transform', `translate(0,${height})`)
                    .call(d3.axisBottom(x)
                        .tickFormat((d, i) => i % 2 === 0 ? d : '')) // Show every other label to prevent overlap
                    .selectAll('text')
                    .attr('transform', 'translate(-10,5)rotate(-45)')
                    .style('text-anchor', 'end')
                    .style('fill', 'white');
                    
                // Collect all series values for Y scale
                const allValues = [];
                Object.keys(data.series).forEach(column => {
                    const values = data.series[column].slice(-maxDates);
                    allValues.push(...values.filter(v => v !== null && v !== undefined));
                });
                
                // Y scale with 10% padding at top
                const maxVal = d3.max(allValues) || 1;
                const y = d3.scaleLinear()
                    .domain([0, maxVal * 1.1])
                    .range([height, 0]);
                    
                // Add Y axis
                svg.append('g')
                    .call(d3.axisLeft(y)
                        .ticks(5)
                        .tickFormat(d => this.formatTickValue(d)))
                    .selectAll('text')
                    .style('fill', 'white');
                    
                // Add Y axis label
                svg.append('text')
                    .attr('class', 'y-axis-label')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -60)
                    .attr('x', -height/2)
                    .attr('text-anchor', 'middle')
                    .style('fill', 'white')
                    .text('Value');
                    
                // Add grid lines
                svg.append('g')
                    .attr('class', 'grid-lines')
                    .selectAll('line')
                    .data(y.ticks(5))
                    .enter()
                    .append('line')
                    .attr('x1', 0)
                    .attr('x2', width)
                    .attr('y1', d => y(d))
                    .attr('y2', d => y(d))
                    .attr('stroke', 'rgba(255,255,255,0.1)')
                    .attr('stroke-dasharray', '3,3');
                    
                // Calculate bar width based on number of series
                const columnCount = Object.keys(data.series).length;
                const groupPadding = 0.2; // 20% of the band width for padding between groups
                const barWidth = (x.bandwidth() * (1 - groupPadding)) / columnCount;
                
                // Color scale for the series
                const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
                
                // Draw bars for each series
                let columnIndex = 0;
                Object.keys(data.series).forEach(column => {
                    const seriesValues = data.series[column].slice(-maxDates);
                    
                    // Create a group for this series
                    const seriesGroup = svg.append('g')
                        .attr('class', `series-${columnIndex}`);
                        
                    // Add bars
                    seriesGroup.selectAll('rect')
                        .data(seriesValues)
                        .enter()
                        .append('rect')
                        .attr('x', (d, i) => x(recentDates[i]) + (barWidth * columnIndex) + (x.bandwidth() * groupPadding / 2))
                        .attr('y', d => d === null ? height : y(d))
                        .attr('width', barWidth)
                        .attr('height', d => d === null ? 0 : height - y(d))
                        .attr('fill', colorScale(column))
                        .attr('rx', 2) // Rounded corners
                        .attr('opacity', 0.8)
                        .on('mouseover', function(event, d) {
                            // Highlight on hover
                            d3.select(this)
                                .attr('opacity', 1)
                                .attr('stroke', 'white')
                                .attr('stroke-width', 1);
                                
                            // Show tooltip
                            const i = seriesValues.indexOf(d);
                            const tooltip = d3.select(container).append('div')
                                .attr('class', 'chart-tooltip')
                                .style('position', 'absolute')
                                .style('background-color', 'rgba(0,0,0,0.9)')
                                .style('color', 'white')
                                .style('padding', '8px')
                                .style('border-radius', '4px')
                                .style('font-size', '12px')
                                .style('z-index', 100)
                                .style('pointer-events', 'none');
                                
                            tooltip.html(`
                                <div><strong>${column}</strong></div>
                                <div>Date: ${recentDates[i]}</div>
                                <div>Value: ${d === null ? 'No data' : this.formatValue(d)}</div>
                            `);
                            
                            // Position tooltip
                            const tooltipNode = tooltip.node();
                            const eventRect = this.getBoundingClientRect();
                            const containerRect = container.getBoundingClientRect();
                            
                            tooltip
                                .style('left', `${eventRect.left - containerRect.left + eventRect.width/2}px`)
                                .style('top', `${eventRect.top - containerRect.top - tooltipNode.offsetHeight - 5}px`)
                                .style('transform', 'translateX(-50%)');
                        })
                        .on('mouseout', function() {
                            // Remove highlight
                            d3.select(this)
                                .attr('opacity', 0.8)
                                .attr('stroke', null);
                                
                            // Remove tooltip
                            d3.select(container).selectAll('.chart-tooltip').remove();
                        });
                        
                    columnIndex++;
                });
                
                // Add legend
                const legend = svg.append('g')
                    .attr('class', 'chart-legend')
                    .attr('transform', `translate(${width + 20}, 0)`);
                    
                Object.keys(data.series).forEach((column, i) => {
                    const legendItem = legend.append('g')
                        .attr('transform', `translate(0, ${i * 25})`);
                        
                    legendItem.append('rect')
                        .attr('width', 15)
                        .attr('height', 15)
                        .attr('rx', 2)
                        .attr('fill', colorScale(column));
                        
                    legendItem.append('text')
                        .attr('x', 25)
                        .attr('y', 12)
                        .style('fill', 'white')
                        .style('font-size', '12px')
                        .text(column);
                });
            }
        };

        // Replace changeVisualization function with ChartFactory implementation
        function changeVisualization() {
            const vizType = document.getElementById('vizTypeSelector').value;
            const chartContainer = document.getElementById('chartContainer');
            
            if (!chartContainer) return;
            
            try {
                // Get country code from selected country
                const countryEl = document.getElementById(`country-${window.globeInstance.selectedCountry}`);
                const countryCode = countryEl ? countryEl.getAttribute('data-country-code') : null;
                
                if (!countryCode) {
                    console.error("No country selected");
                    chartContainer.innerHTML = `
                        <div style="color: white; text-align: center; padding: 20px;">
                            <h3>No Country Selected</h3>
                            <p>Please select a country first</p>
                        </div>
                    `;
                    return;
                }
                
                // Create chart using factory
                ChartFactory.createChart(chartContainer, countryCode, vizType);
            } catch (error) {
                console.error("Error creating visualization:", error);
                chartContainer.innerHTML = `
                    <div style="color: white; text-align: center; padding: 20px;">
                        <h3>Visualization Error</h3>
                        <p>${error.message || "Failed to create visualization"}</p>
                    </div>
                `;
            }
        }
    </script>
</body>

</html>
